options{  IGNORE_CASE = false;  STATIC = false;}PARSER_BEGIN(LdapFilter)package org.ant4eclipse.core.ldapfilter;import java.util.Properties;import java.util.List;import java.util.LinkedList;import java.util.Iterator;import java.util.regex.Pattern;public class LdapFilter{  /** the (scoped) properties **/  private Properties _properties = new Properties();  /**   * <p>   * Creates a new instance of type {@link LdapFilter}.   * </p>   *   * @param properties the (scoped) properties   * @param stream the input stream   */  public LdapFilter(Properties properties, java.io.InputStream stream)  {    this (stream);    // assert properies != null    if (properties == null)    {      throw new RuntimeException();    }    // set properties    _properties = properties;  }  public static void main(String args []) throws ParseException  {    Properties map = new Properties();    map.put("papa", "gerd");    map.put("tochter1", "liena");    map.put("tochter2", "annie");    new LdapFilter(map, System.in).validate();  }  private boolean equal(String attributeKey, String value)  {    if (!_properties.containsKey(attributeKey))    {      return false;    }    if (isPresentValue(value))    {      return true;    }    String scopedProperty = _properties.getProperty(attributeKey);    String regExpValue = value.replaceAll("\\*", ".*");    return Pattern.matches(regExpValue, scopedProperty);  }  private boolean approx(String attributeKey, String value) throws ParseException  {    denyWildcardValue(value);    return equal(attributeKey, value);  }  private boolean greater(String attributeKey, String value) throws ParseException  {    denyWildcardValue(value);    return true;  }  private boolean less(String attributeKey, String value) throws ParseException  {    denyWildcardValue(value);    return true;  }  private void denyWildcardValue(String value) throws ParseException  {    if (value.indexOf('*') != - 1)    {      throw new ParseException("Invalid filter definition.");    }  }  private boolean isPresentValue(String value)  {    if ("*".equals(value))    {      return true;    }    return false;  }}PARSER_END(LdapFilter)SKIP : /* WHITE SPACE */{  "\r"| "\n"| "\t"}TOKEN :{  < EQUAL : "=" >| < APPROX : "~=" >| < GREATER : ">=" >| < LESS : "<=" >| < AND : "&" >| < OR : "|" >| < NOT : "!" >| < BRACKET_OPEN : "(" >| < BRACKET_CLOSE : ")" >| < STRING : ([ "a"-"z", "A"-"Z", "0"-"9", "_", "-", "." ])+ >| < WILDCARD_STRING : ([ "*", "a"-"z", "A"-"Z", "0"-"9", "_", "-", "." ])+ >}boolean validate() :{  boolean value;}{  value = filter() < EOF >  {    return value;  }}/** * filter = "(" filtercomp ")" */boolean filter() :{  boolean value;}{  < BRACKET_OPEN >  (    value = filtercomp()  )  < BRACKET_CLOSE >  {    return value;  }}/** * filtercomp = and / or / not / attributeValueComparison */boolean filtercomp() :{  boolean value;}{  (    value = and()  | value = or()  | value = not()  | value = attributeValueComparison()  )  {    return value;  }}/** * simple     = attr filtertype value * filtertype = equal / approx / greater / less * equal      = "=" * approx     = "~=" * greater    = ">=" * less       = "<=" */boolean attributeValueComparison() :{  Token attribute = null;  Token value = null;  Token operator = null;}{  attribute = < STRING >  (    operator = < EQUAL >  | operator = < APPROX >  | operator = < GREATER >  | operator = < LESS >  )  (    value = < STRING >  | value = < WILDCARD_STRING >  )  {    switch (operator.kind)    {      case LdapFilterConstants.EQUAL :      {        return equal(attribute.image, value.image);      }      case LdapFilterConstants.APPROX :      {        return equal(attribute.image, value.image);      }      case LdapFilterConstants.GREATER :      {        return approx(attribute.image, value.image);      }      case LdapFilterConstants.LESS :      {        return less(attribute.image, value.image);      }      default :      return false;    }  }}/** * not = "!" filter  */boolean not() :{  boolean filterresult;}{  < NOT > filterresult = filter()  {    return !filterresult;  }}/** *  and = "&" filterlist */boolean and() :{  List values;}{  < AND > values = filterlist()  {    for (Iterator iterator = values.iterator();    iterator.hasNext();    )    {      Boolean value = (Boolean) iterator.next();      if (value.booleanValue() == false)      {        return false;      }    }    return true;  }}/** * or = "|" filterlist */boolean or() :{  List values;}{  < OR > values = filterlist()  {    for (Iterator iterator = values.iterator();    iterator.hasNext();    )    {      if (((Boolean) iterator.next()).booleanValue())      {        return true;      }    }    return false;  }}/** * filterlist = 1*filter */List filterlist() :{  List values = new LinkedList();  boolean value;}{  value = filter()  {    values.add(new Boolean(value));  }  (    value = filter()    {      values.add(new Boolean(value));    }  )+  {    return values;  }}