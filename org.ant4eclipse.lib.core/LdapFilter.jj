options{  IGNORE_CASE = false;  STATIC = false;}PARSER_BEGIN(LdapFilter)package org.ant4eclipse.lib.core.ldapfilter;import java.util.List;import java.util.Map;import java.util.HashMap;import java.util.LinkedList;import java.util.Iterator;import java.util.regex.Pattern;/** * <p> * Implements a filter for LDAP strings. Usage: * <code>new LdapFilter(map, System.in).validate()</code > * </p> *  * @author Gerd W&uuml;therich (gerd@gerd-wuetherich.de) */public class LdapFilter{  /** the (scoped) properties **/  private Map _properties = new HashMap();  /**   * <p>   * Creates a new instance of type {@link LdapFilter}.   * </p>   *   * @param properties the (scoped) properties   * @param stream the input stream   */  public LdapFilter(Map properties, java.io.InputStream stream)  {    this (stream);    // assert properies != null    if (properties == null)    {      throw new RuntimeException();    }    // set properties    _properties = properties;  }  public LdapFilter(Map properties, java.io.Reader stream)  {    this (stream);    // assert properies != null    if (properties == null)    {      throw new RuntimeException();    }    // set properties    _properties = properties;  }  private boolean equals(String attributeKey, String value)  {    if (!_properties.containsKey(attributeKey))    {      return false;    }    if (isPresentValue(value))    {      return true;    }    String scopedProperty = (String) _properties.get(attributeKey);    String regExpValue = value.replaceAll("\\*", ".*");    return Pattern.matches(regExpValue, scopedProperty);  }  private boolean approx(String attributeKey, String value) throws ParseException  {    denyWildcardValue(value);    return equals(attributeKey, value);  }  private boolean greater(String attributeKey, String value) throws ParseException  {    denyWildcardValue(value);    return true;  }  private boolean less(String attributeKey, String value) throws ParseException  {    denyWildcardValue(value);    return true;  }  private void denyWildcardValue(String value) throws ParseException  {    if (value.indexOf('*') != - 1)    {      throw new ParseException("Invalid filter definition.");    }  }  private boolean isPresentValue(String value)  {    if ("*".equals(value))    {      return true;    }    return false;  }  public static void main(String args []) throws ParseException  {    Map map = new HashMap();    map.put("papa", "gerd");    map.put("tochter1", "liena");    map.put("tochter2", "annie");    new LdapFilter(map, System.in).validate();  }}PARSER_END(LdapFilter)SKIP : /* WHITE SPACE */{  "\r"| "\n"| "\t"}TOKEN :{  < EQUAL : "=" >| < APPROX : "~=" >| < GREATER : ">=" >| < LESS : "<=" >| < AND : "AND" >| < AND_ORG : "&" >| < OR : "OR" >| < OR_ORG : "|" >| < NOT : "NOT" >| < NOT_ORG : "!" >| < BRACKET_OPEN : "(" >| < BRACKET_CLOSE : ")" >| < STRING : ([ "a"-"z", "A"-"Z", "0"-"9", "_", "-", "." ])+ >| < WILDCARD_STRING : ([ "*", "a"-"z", "A"-"Z", "0"-"9", "_", "-", "." ])+ >}boolean validate() :{  boolean value;}{  value = filter() < EOF >  {    return value;  }}/** * filter = "(" filtercomp ")" */boolean filter() :{  boolean value;}{  < BRACKET_OPEN >  (    value = filtercomp()  )  < BRACKET_CLOSE >  {    return value;  }}/** * filtercomp = and / or / not / attributeValueComparison */boolean filtercomp() :{  boolean value;}{  (    value = and()  | value = or()  | value = not()  | value = attributeValueComparison()  )  {    return value;  }}/** * simple     = attr filtertype value * filtertype = equal / approx / greater / less * equal      = "=" * approx     = "~=" * greater    = ">=" * less       = "<=" */boolean attributeValueComparison() :{  Token attribute = null;  Token value = null;  Token operator = null;}{  attribute = < STRING >  (    operator = < EQUAL >  | operator = < APPROX >  | operator = < GREATER >  | operator = < LESS >  )  (    value = < STRING >  | value = < WILDCARD_STRING >  )  {    switch (operator.kind)    {      case LdapFilterConstants.EQUAL :      {        return equals(attribute.image, value.image);      }      case LdapFilterConstants.APPROX :      {        return approx(attribute.image, value.image);      }      case LdapFilterConstants.GREATER :      {        return greater(attribute.image, value.image);      }      case LdapFilterConstants.LESS :      {        return less(attribute.image, value.image);      }      default :      return false;    }  }}/** * not = "!" filter  */boolean not() :{  boolean filterresult;}{  (    < NOT >  | < NOT_ORG >  )  filterresult = filter()  {    return !filterresult;  }}/** *  and = "&" filterlist */boolean and() :{  List values;}{  (    < AND >  | < AND_ORG >  )  values = filterlist()  {    for (Iterator iterator = values.iterator();    iterator.hasNext();    )    {      Boolean value = (Boolean) iterator.next();      if (value.booleanValue() == false)      {        return false;      }    }    return true;  }}/** * or = "|" filterlist */boolean or() :{  List values;}{  (    < OR >  | < OR_ORG >  )  values = filterlist()  {    for (Iterator iterator = values.iterator();    iterator.hasNext();    )    {      if (((Boolean) iterator.next()).booleanValue())      {        return true;      }    }    return false;  }}/** * filterlist = 1*filter */List filterlist() :{  List values = new LinkedList();  boolean value;}{  value = filter()  {    values.add(Boolean.valueOf(value));  }  (    value = filter()    {      values.add(Boolean.valueOf(value));    }  )+  {    return values;  }}